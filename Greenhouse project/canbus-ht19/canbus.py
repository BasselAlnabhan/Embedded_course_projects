import os
import sys
import json
from datetime import datetime
from service import generate_can_service
from generators.candata import generate_canbus_data
from generators.prototype import generate_canbus_header
from generators.implementation import generate_canbus_implementation

# How the datetime should be formatted everywhere.
DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"
COMMON_FILE_NAME = "common.h"

nodes = ["com", "act", "sns", "hmi"]
modes = ["development", "production", "test"]

# Current node.
node = ''
# Current mode.
mode = ''


def create_path(path):
    try:
        if not os.path.exists(path):
            os.makedirs(path)
    except OSError as e:
        print("Could not folders to the file: {}").format(e)


def print_error():
    print("Usage: canbus.py -node <com|act|sns|hmi> -mode <development|production|test>")
    exit(1)


# Get the messages from the json related to the node.
def get_node_messages(messages):
    node_messages = []
    for message in messages:
        if node == message['setter']:
            node_messages.append(message)
        else:
            for signal in message["signals"]:
                if node in signal["getters"]:
                    node_messages.append(message)
                    break
    return node_messages


# Get the defines from the json related to the node.
def get_node_defines(messages):
    defines = []
    for message in messages:
        for signal in message["signals"]:
            if "values" in signal and signal["values"] not in defines and (node == message['setter'] or node in signal['getters']):
                defines.append(signal["values"])
    return defines


# Generate the common header file.
def generate_common_h(node_name, canbus, defines, messages):
    text = ""
    # Look at this sweet multiline, pretty, right?
    text += ("/**\n"
             " * @file common.h\n"
             " * @author Mr.PythonScript\n"
             " * @brief Contains global constants for the {} node.\n"
             " *        DO NOT EDIT THIS FILE BY HAND.\n"
             " * @version 0.1\n"
             " * @date {}\n"
             " *\n"
             " * @copyright Copyright (c) 2020\n"
             " *\n"
             " */\n\n").format(node_name, datetime.now().strftime(DATETIME_FORMAT))

    text += "#ifndef COMMON_H\n"
    text += "#define COMMON_H\n\n"

    if mode != "production":
        text += "#define DEVELOPMENT\n\n"

    if node == "sns":
        text += "#define ADC_RESOLUTION (10U)\n"
        text += "#define MAP(value, min_from, max_from, min_to, max_to) ((float)(min_to) + (float)(value) * ((float)(max_to) - (float)(min_to)) / ((float)(max_from) - (float)(min_from)))\n\n"

    # Define values.
    define_values = []
    for value in defines:
        for index, macro in enumerate(canbus["defines"][value]):
            if macro not in define_values:
                define_values.append(macro)
                text += "#define {} ({}U)\n".format(macro, index)
        text += "\n"

    # Define ranges
    if node in ['com', 'hmi']:
        for message in messages:
            for signal in message['signals']:
                if node == message['setter'] and 'range' in signal:
                    text += '#define {0}_LOWER ({1}U)\n'.format(
                        signal['name'].upper(), signal['range'][0])
                    text += '#define {0}_UPPER ({1}U)\n\n'.format(
                        signal['name'].upper(), signal['range'][1])

    # Defines value messages.
    if node in ['com', 'hmi']:
        define_values = []
        for value in defines:
            for index, macro in enumerate(canbus["defines"][value]):
                if macro not in define_values:
                    try:
                        define_values.append(macro)
                        text += "#define {}_MSG \"{}\"\n".format(
                            macro, canbus["constants"][macro])
                    except:
                        print("Could not find description for {}".format(macro))
            text += "\n"

    text += "\n#endif /* COMMON_H */\n"

    # Open the file, and then write, good times:
    with open(path_common+COMMON_FILE_NAME, 'w+') as f:
        try:
            f.write(text)
        except:
            print("Failed to write to {}common.h".format(path_common))
        finally:
            f.close()


def main(argv):
    with open("canbus.json") as file:
        try:
            canbus = json.load(file)
        except:
            print("Failed to read the json file")
            exit(2)
        finally:
            file.close()

    # Let's fetch those nice messages related to the current node.
    # And delete the rest, save memory you know.
    messages = get_node_messages(canbus["messages"])
    del canbus["messages"]

    # Then let's get the defines, those that are going to
    # be generated in our common.h file
    defines = get_node_defines(messages)
    defines.append("noyes")

    # And then generate, just like that.
    generate_common_h(canbus["nodes"][node]["name"], canbus, defines, messages)

    # Generate the can service.
    generate_can_service(node, mode, path_canbus, messages, canbus['defines'])

    # Generate the canbus header.
    generate_canbus_header(node, mode, path_canbus, messages, canbus)

    generate_canbus_implementation(
        node, mode, path_canbus, canbus['defines'], messages)

    if node in ['com', 'hmi']:
        if node == 'com':
            create_path('../esp32/include')
        generate_canbus_data(
            node, path_canbus, canbus['nodes'], canbus['defines'], messages)


if len(sys.argv) == 5:
    if sys.argv[1] != '-node' or sys.argv[3] != '-mode':
        print_error()

    if sys.argv[2] not in nodes or sys.argv[4] not in modes:
        print_error()

    node = sys.argv[2]
    mode = sys.argv[4]
else:
    print_error()

# Path to canbus file.
path_canbus = ("../teensy/lib/canbus" if node == "com" else "../lib/canbus")
create_path(path_canbus)

# Path to comment file.
path_common = ("../teensy/include/" if node == "com" else "../include/")
create_path(path_common)

if __name__ == "__main__":
    main(sys.argv[1:])

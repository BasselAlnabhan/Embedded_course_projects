import os
import sys
import copy
import shutil
from datetime import datetime


# Write to file
def write_file(filename, text):
    with open(filename, 'w+') as file:
        try:
            file.write(text.strip())
        except:
            print("Failed to write to {0}".format(filename))
            exit(1)


# Copy files
def copy_files(path):
    shutil.copyfile("sources/can_signal.h", "{0}/can_signal.h".format(path))
    shutil.copyfile("sources/can_service.h", "{0}/can_service.h".format(path))
    shutil.copyfile("sources/FlexCAN.cpp", "{0}/FlexCAN.cpp".format(path))
    shutil.copyfile("sources/FlexCAN.h", "{0}/FlexCAN.h".format(path))
    shutil.copyfile("sources/kinetis_flexcan.h",
                    "{0}/kinetis_flexcan.h".format(path))


def generate_header(mode):
    text = '/**\n'
    text += ' * @file can_service.cpp\n'
    text += ' * @author Bengt Cruz (bengt.cruz@ya.se)\n'
    text += ' * @brief The generated implementation of the CAN service.\n'
    text += ' *        DO NOT EDIT THIS FILE BY HAND!\n'
    text += ' * @version 0.1\n'
    text += ' * @date {}\n'.format(
        datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
    text += ' * \n'
    text += ' * @copyright Copyright (c) 2020\n'
    text += ' * \n'
    text += ' */\n\n'
    if mode != 'test':
        text += '#include <FlexCAN.h>\n'
    text += '#include <can_signal.h>\n'
    text += '#include <can_service.h>\n\n'
    text += '#define BYTE_SIZE (8U)\n'
    if mode == 'test':
        text += '\ntypedef struct\n{\n'
        text += '\tuint32_t id;\n'
        text += '\tuint16_t timestamp;\n'
        text += '\tstruct\n\t{\n'
        text += '\t\tuint8_t extended : 1;\n'
        text += '\t\tuint8_t remote : 1;\n'
        text += '\t\tuint8_t overrun : 1;\n'
        text += '\t\tuint8_t reserved : 5;\n'
        text += '\t} flags;\n'
        text += '\tuint8_t len;\n'
        text += '\tuint8_t buf[8];\n'
        text += '} CAN_message_t;\n\n'
    else:
        text += '#define BIT_RATE (250000)\n'
        text += '#define WRITE_PER_READ (10U)\n\n'
        text += 'static void read_messages(void);\n'
        text += 'static void write_messages(void);\n\n'
    return text


# Get the length of a message
def get_message_length(message):
    length = 0
    for signal in message['signals']:
        if length < signal['start'] + signal['length']:
            length = signal['start'] + signal['length']
    if length % 8 == 0:
        length = int(length / 8)
    else:
        length = int(length / 8) + 1
    return length


# Generate messages
def generate_node_messages(messages):
    text = 'static CAN_message_t messages[] = {\n'
    for message in messages:
        text += '\t{0}.id = {1}, .timestamp = 0, '.format('{', message['id'])
        text += '.flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, '
        text += '.len = {0}'.format(get_message_length(message)
                                    ) + ', .buf = {0}},\n'
    return text[:-2] + '};\n'


# Generate can_signal_write
def generate_can_signal_write():
    text = '\nvoid can_signal_write(uint8_t msg_index, uint8_t start, uint8_t length, uint64_t value)\n'
    text += '{\n'
    text += '\tuint8_t pos = start % BYTE_SIZE;\n'
    text += '\tuint8_t index = start / BYTE_SIZE;\n'
    text += '\tfor (uint8_t i = 0; i < length; i++)\n'
    text += '\t{\n'
    text += '\t\tuint8_t bit = (uint8_t)((value >> i) & (uint64_t)1);\n\n'
    text += '\t\tmessages[msg_index].buf[index] &= (~((uint8_t)1 << pos));\n'
    text += '\t\tmessages[msg_index].buf[index] |= (bit << pos);\n\n'
    text += '\t\tpos++;\n'
    text += '\t\tif (pos % BYTE_SIZE == 0)\n'
    text += '\t\t{\n'
    text += '\t\t\tpos = 0;\n'
    text += '\t\t\tindex++;\n'
    text += '\t\t}\n'
    text += '\t}\n'
    text += '}\n'
    return text


# Generate can_signal_read
def generate_can_signal_read():
    text = '\nuint64_t can_signal_read(uint8_t msg_index, uint8_t start, uint8_t length)\n'
    text += '{\n'
    text += '\tuint64_t value = 0;\n'
    text += '\tuint8_t pos = start % BYTE_SIZE;\n'
    text += '\tuint8_t index = start / BYTE_SIZE;\n'
    text += '\n'
    text += '\tfor (uint8_t i = 0; i < length; i++)\n'
    text += '\t{\n'
    text += '\t\tuint64_t bit = ((uint64_t)(messages[msg_index].buf[index] >> pos) & (uint64_t)1);\n'
    text += '\t\tvalue |= (bit << i);\n'
    text += '\n'
    text += '\t\tpos++;\n'
    text += '\t\tif (pos % BYTE_SIZE == 0)\n'
    text += '\t\t{\n'
    text += '\t\t\tpos = 0;\n'
    text += '\t\t\tindex++;\n'
    text += '\t\t}\n'
    text += '\t}\n'
    text += '\n'
    text += '\treturn value;\n'
    text += '}\n'
    return text[:-2]+'}\n'


# Generate can_servie_init
def generate_can_service_init(node, mode, messages):
    rx_messages = []
    for message in messages:
        for signal in message['signals']:
            if node in signal['getters']:
                rx_messages.append(message['id'])
                break
    text = '\nvoid can_service_init(void)\n'
    text += '{\n'
    if mode != 'test':
        text += '\tCan0.begin(BIT_RATE);\n\n'
        text += '\tuint16_t rx_messages[] = {'
        text += ', '.join([str(elem) for elem in rx_messages]) + '};\n'
        text += '\tCAN_filter_t filter = {.id = 0xFFFFFFFFU, .flags = {.extended = 1, .remote = 0, .reserved = 0}};\n\n'
        text += '\tfor (uint8_t i = 0; i < NUM_MAILBOXES; ++i)\n'
        text += '\t{\n\t\tCan0.setFilter(filter, i);\n'
        text += '\t\tCan0.setMask(0U, i);\n\t}\n\n'
        text += '\tfor (uint8_t i = 0; i < (sizeof(rx_messages) / sizeof(*rx_messages));i++)\n'
        text += '\t{\n'
        text += '\t\tfilter.flags.remote = 0;\n'
        text += '\t\tfilter.flags.extended = 0;\n'
        text += '\t\tfilter.flags.reserved = 0;\n'
        text += '\t\tfilter.id = rx_messages[i];\n'
        text += '\t\tCan0.setFilter(filter, i);\n'
        text += '\t\tCan0.setMask(~((uint32_t)0), i);\n'
        text += '\t}\n'
    text += '}\n'
    return text


# Generate read_messages
def generate_read_messages():
    text = '\nstatic void read_messages(void)\n'
    text += '{\n'
    text += '\tif (Can0.available())\n'
    text += '\t{\n'
    text += '\t\tCAN_message_t msg;\n'
    text += '\t\twhile (Can0.read(msg))\n'
    text += '\t\t{\n'
    text += '\t\t\tfor (uint8_t i = 0; i < (sizeof(messages) / sizeof(CAN_message_t)); i++)\n'
    text += '\t\t\t{\n'
    text += '\t\t\t\tif(msg.id == messages[i].id)\n'
    text += '\t\t\t\t{\n'
    text += '\t\t\t\t\tmessages[i] = msg;\n'
    text += '\t\t\t\t\tbreak;\n'
    text += '\t\t\t\t}\n'
    text += '\t\t\t}\n'
    text += '\t\t}\n'
    text += '\t}\n'
    text += '}\n'
    return text


# Generate write_messages
def generate_write_messages(node, messages):
    tx_messages = []
    for key, message in enumerate(messages):
        if node == message['setter']:
            tx_messages.append(key)
    text = '\nstatic void write_messages(void)\n'
    text += '{\n'
    text += '\tuint8_t tx_messages[] = {'
    text += ', '.join([str(elem) for elem in tx_messages]) + '};\n'
    text += '\tfor (uint8_t i = 0; i < sizeof(tx_messages); i++)\n'
    text += '\t{\n'
    text += '\t\tCan0.write(messages[tx_messages[i]]);\n'
    text += '\t}\n'
    text += '}\n'
    return text


# Generate can_service_run
def generate_can_service_run(mode):
    text = '\nvoid can_service_run(void)\n'
    text += '{\n'
    if mode != 'test':
        text += '\tstatic uint8_t quanta = 0;\n\n'
        text += '\tquanta++;\n\n'
        text += '\twrite_messages();\n\n'
        text += '\tif (quanta == WRITE_PER_READ)\n'
        text += '\t{\n'
        text += '\t\tread_messages();\n'
        text += '\t\tquanta = 0;\n'
        text += '\t}\n'
    text += '}\n'
    return text


def get_output_signals(node, messages):
    temp = dict()
    for message in messages:
        if node == message['setter']:
            for signal in message['signals']:
                temp[signal['name']] = dict({
                    'type': signal['type'],
                    'length': '{0}'.format((signal['length'] - 1) if ('validate' in signal or 'overwrite' in signal) else signal['length']),
                    'description': signal['comment'][:1].upper() + signal['comment'][1:],
                    'value': '[{0}, {1}]'.format(signal['range'][0], signal['range'][1]) if 'range' in signal else '{0}'.format(' | '.join(signal['values']))
                })
                if 'overwrite' in signal:
                    temp['overwrite_{}'.format(signal['name'])] = dict({
                        'type': 'uint8_t',
                        'length': '1',
                        'description': 'Overwrite {}'.format(signal['comment']),
                        'value': 'NO | YES'
                    })

    return temp


def get_input_signals(node, messages):
    temp = dict()
    for message in messages:
        for signal in message['signals']:
            if node in signal['getters']:
                temp[signal['name']] = dict({
                    'type': signal['type'],
                    'length': '{0}'.format((signal['length'] - 1) if ('validate' in signal or 'overwrite' in signal) else signal['length']),
                    'description': signal['comment'][:1].upper() + signal['comment'][1:],
                    'value': '[{0}, {1}]'.format(signal['range'][0], signal['range'][1]) if 'range' in signal else '{0}'.format(' | '.join(signal['values']))
                })
                if 'validate' in signal:
                    temp['validate_{}'.format(signal['name'])] = dict({
                        'type': 'uint8_t',
                        'length': '1',
                        'description': 'Is {} valid?'.format(signal['comment']),
                        'value': 'UNINITIALIZED | OKAY'
                    })
                if 'overwrite' in signal:
                    temp['is_{}_overwritten'.format(signal['name'])] = dict({
                        'type': 'uint8_t',
                        'length': '1',
                        'description': 'Is {} overwritten?'.format(signal['comment']),
                        'value': 'NO | YES'
                    })
    return temp


def get_max_size(signals):
    temp = dict({
        'name': len("Output Signals"),
        'description': 0,
        'length': 0,
        'value': 0,
        'type': 0
    })

    for key in signals:
        if temp['name'] < len(key):
            temp['name'] = len(key)

    for key in signals:
        if temp['type'] < len(signals[key]['type']):
            temp['type'] = len(signals[key]['type'])

    for key in signals:
        if temp['length'] < len(signals[key]['length']):
            temp['length'] = len(signals[key]['length'])

    for key in signals:
        if temp['description'] < len(signals[key]['description']):
            temp['description'] = len(signals[key]['description'])

    for key in signals:
        if temp['value'] < len(signals[key]['value']):
            temp['value'] = len(signals[key]['value'])

    return temp


def generate_signals(node, path, messages):
    signals = get_output_signals(node, messages)
    temp = get_max_size(signals)

    text = '# The CAN Signals\n\n'
    text += '{0} | {1} | Length | {2} | Values\n'.format('Output Signals'.ljust(
        temp['name']), 'Type'.ljust(temp['type']), 'Description'.ljust(temp['description']))
    text += '-'*(temp['name'] + temp['type'] + temp['length'] +
                 temp['description'] + temp['value'] + 16) + '\n'

    for key in signals:
        text += '{0} | {1} | {2} | {3} | {4}\n'.format(key.ljust(
            temp['name']), signals[key]['type'].ljust(temp['type']),
            '  {0}  '.format(signals[key]['length'].rjust(temp['length'])),
            signals[key]['description'].ljust(temp['description']), signals[key]['value'])

    signals = get_input_signals(node, messages)
    temp = get_max_size(signals)
    text += '\n\n{0} | {1} | Length | {2} | Values\n'.format('Input Signals'.ljust(
        temp['name']), 'Type'.ljust(temp['type']), 'Description'.ljust(temp['description']))
    text += '-'*(temp['name'] + temp['type'] + temp['length'] +
                 temp['description'] + temp['value'] + 16) + '\n'

    for key in signals:
        text += '{0} | {1} | {2} | {3} | {4}\n'.format(key.ljust(
            temp['name']), signals[key]['type'].ljust(temp['type']),
            '  {0}  '.format(signals[key]['length'].rjust(temp['length'])),
            signals[key]['description'].ljust(temp['description']), signals[key]['value'])

    return text


def generate_can_service(node, mode, path, messages, defines):
    copy_files(path)
    messages = copy.deepcopy(messages)

    text = generate_header(mode)
    text += generate_node_messages(messages)
    text += generate_can_signal_write()
    text += generate_can_signal_read()
    text += generate_can_service_init(node, mode, messages)
    text += generate_can_service_run(mode)
    if mode != 'test':
        text += generate_read_messages()
        text += generate_write_messages(node, messages)
    write_file('{0}/can_service.cpp'.format(path), text)

    for message in messages:
        for signal in message['signals']:
            if 'values' in signal:
                signal['values'] = defines[signal['values']]

    text = generate_signals(node, path, messages)
    write_file('{0}/signals.txt'.format(path), text)

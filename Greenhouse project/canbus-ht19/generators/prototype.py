from datetime import datetime


def create_canbus_header(text, path):
    with open(path+"/canbus.h", 'w+') as f:
        try:
            f.write(text)
        except:
            print("Failed to write to {}canbus.h".format(path))
        finally:
            f.close()


def generate_header_content(node_name):
    return ("/**\n"
            " * @file canbus.h\n"
            " * @author Jesper Mellquist\n"
            " * @brief Generated interface for the canbus module for the {1} node.\n"
            " *        DO NOT EDIT THIS FILE BY HAND.\n"
            " * @version 0.1\n"
            " * @date {0}\n"
            " *\n"
            " * @copyright Copyright (c) 2020\n"
            " *\n"
            " */\n\n"
            "#ifndef CANBUS_H\n"
            "#define CANBUS_H\n\n"
            "#include <stdint.h>\n"
            "#include <stdbool.h>\n"
            "\n").format(datetime.now().strftime("%Y-%m-%d"), node_name)


def generate_overwrite_prototype(node, mode, messages):
    text = ""
    for message in messages:
        for signal in message["signals"]:
            if "overwrite" in signal:
                if node == message['setter']:
                    text += ("/**\n"
                             " * @brief Overwrite {1} value.\n"
                             " *\n"
                             " * @param value YES to enable overwriting, else NO.\n"
                             " */\n"
                             "void overwrite_{0}(uint8_t value);\n\n").format(signal["name"], signal["comment"])
                elif mode == 'test' and node in signal['getters']:
                    text += ("/**\n"
                             " * @brief Overwrite {1} value.\n"
                             " *\n"
                             " * @param value YES to enable overwriting, else NO.\n"
                             " */\n"
                             "void overwrite_test_{0}(uint8_t value);\n\n").format(signal["name"], signal["comment"])
    return text


def generate_is_overwritten_prototype(node, messages):
    text = ""
    for message in messages:
        for signal in message["signals"]:
            if "overwrite" in signal and (node == signal['overwrite'] or node in signal['getters'] or node == message['setter']):
                text += ("/**\n"
                         " * @brief Is {1} overwritten.\n"
                         " *\n"
                         " * @return uint8_t YES if overwritten else NO.\n"
                         " */\n"
                         "uint8_t is_{0}_overwritten(void);\n\n").format(signal["name"], signal["comment"])
    return text


def generate_valid_prototype(node, messages):
    text = ""
    for message in messages:
        for signal in message["signals"]:
            if "validate" in signal and node in signal["getters"]:
                text += ("/**\n"
                         " * @brief Check if {1} is valid or not.\n"
                         " *\n"
                         " * @return uint8_t OKAY if the calibration value is valid, else UNINITIALIZED.\n "
                         " */\n"
                         "uint8_t validate_{0}(void);\n\n").format(signal["name"], signal["comment"])
    return text


def generate_set_prototype(node, mode, messages, defines):
    text = ""
    for message in messages:
        if node == message["setter"]:
            for signal in message["signals"]:
                values = ''
                if "values" in signal:
                    values = "Acceptable values: " + \
                        ", ".join(defines[signal["values"]][:-1]) + \
                        ' or {0}'.format(defines[signal["values"]][-1])
                elif "range" in signal:
                    values = "A number between {0} and {1}".format(
                        signal["range"][0], signal["range"][1])
                text += ("/**\n"
                         " * @brief Set {2}.\n"
                         " *\n"
                         " * @param value {3}.\n"
                         " * @return true if the value is valid\n"
                         " * @return false if the value is not valid\n"
                         " */\n"
                         "bool set_{0}({1} value);\n\n").format(signal["name"], signal["type"], signal["comment"], values)
                if mode == 'test' and node not in signal['getters']:
                    text += ("/**\n"
                             " * @brief Get {2}.\n"
                             " *\n"
                             " * @return {1} {3}.\n"
                             " */\n"
                             "{1} get_test_{0}(void);\n\n").format(signal["name"], signal["type"], signal["comment"], values)
    return text


def generate_get_prototype(node, mode, messages, defines):
    text = ""
    for message in messages:
        for signal in message["signals"]:
            if node in signal["getters"]:
                values = ''
                if "values" in signal:
                    values = "Returns " + \
                        ", ".join(defines[signal["values"]][:-1]) + \
                        ' or {}'.format(defines[signal["values"]][-1])
                elif "range" in signal:
                    values = "A number between {0} and {1}".format(
                        signal["range"][0], signal["range"][1])

                text += ("/**\n"
                         " * @brief Get {3}.\n"
                         " *\n"
                         " * @return {1} {2}.\n"
                         " */\n"
                         "{1} get_{0}(void);\n\n").format(signal["name"], signal["type"], values, signal["comment"])

                if mode == 'test' and node != message['setter']:
                    text += ("/**\n"
                             " * @brief Set {3}.\n"
                             " *\n"
                             " * @param value {2}.\n"
                             " * @return true if the value is valid\n"
                             " * @return false if the value is not valid\n"
                             " */\n"
                             "bool set_test_{0}({1} value);\n\n").format(signal["name"], signal["type"], values, signal["comment"])
    return text


def generate_canbus_header(node, mode, path, messages, canbus):
    text = generate_header_content(canbus["nodes"][node]["name"])
    text += generate_get_prototype(node, mode, messages, canbus["defines"])
    text += generate_set_prototype(node, mode, messages, canbus["defines"])
    text += generate_valid_prototype(node, messages)
    text += generate_overwrite_prototype(node, mode, messages)
    text += generate_is_overwritten_prototype(node, messages)
    text += "\n#endif /* CANBUS_H */"
    create_canbus_header(text, path)
